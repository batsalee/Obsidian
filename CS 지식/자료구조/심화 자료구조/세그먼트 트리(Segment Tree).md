# 세그먼트 트리(Segment Tree)

## 1. 세그먼트 트리란?

구간을 저장하기 위한 트리  
구간합, 구간 내 최소값, 구간 내 최대값 등등 구간내의 값을 빠르게 파악하기 좋은 자료구조  

![[segment tree.png]]

구간합을 예시로 설명하자면 위 사진처럼 7칸짜리 배열이 있다고 할 때  
0 ~ 7번 자리에 들어있는 값들을 트리의 말단 노드인 리프에 놓고  
0 ~ 1번 인덱스 값의 합을 부모노드에, 2 ~ 3번 인덱스 값의 합을 부모노드에, ...  
최종적으로 root에는 모든 배열값들의 합이 위치하는 형태  



## 2. 세그먼트 트리가 없다면?

예를들어 `arr[] = { 1, 2, 3, 4, 5 };`의 배열이 있을 때  
index 0 ~ 2의 구간의 합을 구해라, 1 ~ 3의 구간의 합을 구해라, 2 ~ 4의 구간의 합을 구해라 같은 구간합을 여러번 구하는 문제가 있다면 누적합 알고리즘을 사용하면 된다.  

그런데 만약 구간의 합을 구하는 사이사이에 배열의 값을 바꾸는 요청이 있다면?  
예를들어  
1) index 0~2 구간의 합을 구해라
2) index 2의 값을 7로 변경해라
3) index 1~3 구간의 합을 구해라
4) index 1의 값을 6으로 변경해라
   ...
이런 식으로 있다면  

만약 누적합 알고리즘을 사용한다면 1)처럼 구간합을 구하는 부분은 O(1)로 아주 빠르지만  
2)처럼 값을 변경하는 경우 해당 index의 이후 값을 전부 다 변경해줘야 하므로 O(N)의 시간이 걸린다.  
이런 사이클을 여러번 반복한다면 결국 O(NM)이 된다.  

그냥 매번 반복문으로 구간합을 구한다고 해도  
1)처럼 구간합을 구하는 부분은 O(N)의 시간복잡도이고  
2)처럼 값을 변경하는 것은 O(1)이 되고   
이를 M번 반복한다고 하면 결과적으로 O(NM)이 된다.

반면 세그먼트트리를 사용하면 O(logN)으로 더 효율적으로 해결할 수 있다.  



## 3. 세그먼트 트리 구현 방식

![[Pasted image 20240323125038.png|300x300]]
`int arr[] = { 1, 2, 3, 4, 5 };`가 있을 때 세그먼트 트리의 초기화 모습은 위 사진과 같이 리프노드에 배열의 값들이 있고 그 노드들의 부모는 자식들의 합을 값으로 가지는 구조가 됨  

위 트리를 통해 알 수 있는 것은 5개의 값에 대한 세그먼트 트리를 구현하는데 필요한 노드의 갯수는 9개이고, 트리의 높이는 3이라는 것  

만약 배열의 원소가 짝수개라면?
![[Pasted image 20240323125348.png|300x300]]
