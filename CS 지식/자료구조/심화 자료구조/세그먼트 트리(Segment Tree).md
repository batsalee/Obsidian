# 세그먼트 트리(Segment Tree)

## 1. 세그먼트 트리란?

구간을 저장하기 위한 트리  
구간합, 구간 내 최소값, 구간 내 최대값 등등 구간내의 값을 빠르게 파악하기 좋은 자료구조  

![[segment tree.png]]

구간합을 예시로 설명하자면 위 사진처럼 7칸짜리 배열이 있다고 할 때  
0 ~ 7번 자리에 들어있는 값들을 트리의 말단 노드인 리프에 놓고  
0 ~ 1번 인덱스 값의 합을 부모노드에, 2 ~ 3번 인덱스 값의 합을 부모노드에, ...  
최종적으로 root에는 모든 배열값들의 합이 위치하는 형태  



## 2. 세그먼트 트리가 없다면?

예를들어 `arr[] = { 1, 2, 3, 4, 5 };`의 배열이 있을 때  
index 0 ~ 2의 구간의 합을 구해라, 1 ~ 3의 구간의 합을 구해라, 2 ~ 4의 구간의 합을 구해라 같은 구간합을 여러번 구하는 문제가 있다면 누적합 알고리즘을 사용하면 된다.  

그런데 만약 구간의 합을 구하는 사이사이에 배열의 값을 바꾸는 요청이 있다면?  
예를들어  
1) index 0~2 구간의 합을 구해라
2) index 2의 값을 7로 변경해라
3) index 1~3 구간의 합을 구해라
4) index 1의 값을 6으로 변경해라
   ...
이런 식으로 있다면  

만약 누적합 알고리즘을 사용한다면 1)처럼 구간합을 구하는 부분은 O(1)로 아주 빠르지만  
2)처럼 값을 변경하는 경우 해당 index의 이후 값을 전부 다 변경해줘야 하므로 O(N)의 시간이 걸린다.  
이런 사이클을 여러번 반복한다면 결국 O(NM)이 된다.  

그냥 매번 반복문으로 구간합을 구한다고 해도  
1)처럼 구간합을 구하는 부분은 O(N)의 시간복잡도이고  
2)처럼 값을 변경하는 것은 O(1)이 되고   
이를 M번 반복한다고 하면 결과적으로 O(NM)이 된다.

반면 세그먼트트리를 사용하면 O(logN)으로 더 효율적으로 해결할 수 있다.  



## 3. 세그먼트 트리 공식

![[Pasted image 20240323125038.png|300x250]]
`int arr[] = { 1, 2, 3, 4, 5 };`가 있을 때 세그먼트 트리의 초기화 모습은 위 사진과 같이 리프노드에 배열의 값들이 있고 그 노드들의 부모는 자식들의 합을 값으로 가지는 구조가 됨  

위 트리를 통해 알 수 있는 것은 5개의 값에 대한 세그먼트 트리를 구현하는데 필요한 노드의 갯수는 9개이고, 트리의 높이는 3이라는 것  

만약 배열의 원소가 짝수개라면?  
![[Pasted image 20240323125348.png|300x250]]
위처럼 노드의 갯수는 7개이고 트리의 높이는 2가 된다.  

#### 1) 트리의 index
- 부모노드의 번호 * 2 = 왼쪽 자식 노드  
- 부모노드의 번호 * 2 + 1 = 오른쪽 자식 노드
위의 공식을 사용하기 위해 index 0은 비워두고 사용하지 않는다.  

#### 2) 트리의 높이 구하는 법
- CEIL(log<sub>2</sub>(배열의 크기))
N이 4일땐 CEIL(log<sub>2</sub>4)이므로 2.0의 올림인 2가 트리의 높이이고  
N이 5일땐 CEIL(log<sub>2</sub>5)이므로 2.xxxx의 올림인 3이 트리의 높이이다.

#### 3) 노드의 갯수 구하는 법
- `2^(높이 + 1)`
- 비트연산으로 표현하면 `1 << (높이 + 1)`로 깔끔하다.
리프노드가 full이 아닐 수 있으므로 정확하게 딱 몇개다라고 구하는게 아니라 최대 x개 필요하다고 계산하는 방식이다.  

위 사진들로 확인해보면  
높이가 2인 트리는 노드의 갯수가 8이므로 사용하지 않는 0번 index를 제외하면 7개의 노드가 필요했고  
높이가 3인 트리는 노드의 갯수가 16이고 index 0을 제외한 15칸 중 포화이진트리가 아니라서 15칸 모두 사용하진 않았지만 9칸을 사용하게되는 방식이다.  

#### 정리하면
크기가 N인 배열은  
- 트리의 높이 = CEIL(log<sub>2</sub>N)
- 트리의 크기 = 1 << (높이 + 1)
위 두 공식을 이용해서 트리 구현에 필요한 공간을 설정할 수 있다.  
배열의 크기 * 4로 대충 설정하고 쓰는 경우도 많다고 하니 혹시나 보게되면 알아차리면 될 듯 하다.  



## 4. 세그먼트 트리 구현

C++기준으로는 vector에 재귀를 사용해서 구현한다.  
재귀의 매개변수로 (현재노드번호, 시작범위, 마지막범위)를 사용한다.  
재귀의 첫 호출이라면  
- 현재노드번호 : index 0은 사용하지 않으므로 첫 호출은 1로 설정한다.
- 시작범위 : 배열의 시작범위이므로 0으로 설정한다.
- 마지막범위 : 배열의 마지막범위이므로 N-1로 설정한다.
즉 (1, 0, )