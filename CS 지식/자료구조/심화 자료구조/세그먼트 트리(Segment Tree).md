# 세그먼트 트리(Segment Tree)

## 1. 세그먼트 트리란?

구간을 저장하기 위한 트리  
구간합, 구간 내 최소값, 구간 내 최대값 등등 구간내의 값을 빠르게 파악하기 좋은 자료구조  

![[segment tree.png]]

구간합을 예시로 설명하자면 위 사진처럼 7칸짜리 배열이 있다고 할 때  
0 ~ 7번 자리에 들어있는 값들을 트리의 말단 노드인 리프에 놓고  
0 ~ 1번 인덱스 값의 합을 부모노드에, 2 ~ 3번 인덱스 값의 합을 부모노드에, ...  
최종적으로 root에는 모든 배열값들의 합이 위치하는 형태  



## 2. 세그먼트 트리가 없다면?

예를들어 `arr[] = { 1, 2, 3, 4, 5 };`의 배열이 있을 때  
index 0 ~ 2의 구간의 합을 구해라, 1 ~ 3의 구간의 합을 구해라, 2 ~ 4의 구간의 합을 구해라 같은 구간합을 여러번 구하는 문제가 있다면 누적합 알고리즘을 사용하면 된다.  

그런데 만약 구간의 합을 구하는 사이사이에 배열의 값을 바꾸는 요청이 있다면?  
예를들어  
1) index 0~2 구간의 합을 구해라
2) index 2의 값을 7로 변경해라
3) index 1~3 구간의 합을 구해라
4) index 1의 값을 6으로 변경해라
   ...
이런 식으로 있다면  

만약 누적합 알고리즘을 사용한다면 1)처럼 구간합을 구하는 부분은 O(1)로 아주 빠르지만  
2)처럼 값을 변경하는 경우 해당 index의 이후 값을 전부 다 변경해줘야 하므로 O(N)의 시간이 걸린다.  
이런 사이클을 여러번 반복한다면 결국 O(NM)이 된다.  

그냥 매번 반복문으로 구간합을 구한다고 해도  
1)처럼 구간합을 구하는 부분은 O(N)의 시간복잡도이고  
2)처럼 값을 변경하는 것은 O(1)이 되고   
이를 M번 반복한다고 하면 결과적으로 O(NM)이 된다.

반면 세그먼트트리를 사용하면 O(logN)으로 더 효율적으로 해결할 수 있다.  



## 3. 세그먼트 트리 공식

![[Pasted image 20240323125038.png|300x250]]
`int arr[] = { 1, 2, 3, 4, 5 };`가 있을 때 세그먼트 트리의 초기화 모습은 위 사진과 같이 리프노드에 배열의 값들이 있고 그 노드들의 부모는 자식들의 합을 값으로 가지는 구조가 됨  

위 트리를 통해 알 수 있는 것은 5개의 값에 대한 세그먼트 트리를 구현하는데 필요한 노드의 갯수는 9개이고, 트리의 높이는 3이라는 것  

만약 배열의 원소가 짝수개라면?  
![[Pasted image 20240323125348.png|300x250]]
위처럼 노드의 갯수는 7개이고 트리의 높이는 2가 된다.  

#### 1) 트리의 index
- 부모노드의 번호 * 2 = 왼쪽 자식 노드  
- 부모노드의 번호 * 2 + 1 = 오른쪽 자식 노드
위의 공식을 사용하기 위해 index 0은 비워두고 사용하지 않는다.  

#### 2) 트리의 높이 구하는 법
- CEIL(log<sub>2</sub>(배열의 크기))
N이 4일땐 CEIL(log<sub>2</sub>4)이므로 2.0의 올림인 2가 트리의 높이이고  
N이 5일땐 CEIL(log<sub>2</sub>5)이므로 2.xxxx의 올림인 3이 트리의 높이이다.

#### 3) 노드의 갯수 구하는 법
- `2^(높이 + 1)`
- 비트연산으로 표현하면 `1 << (높이 + 1)`로 깔끔하다.
리프노드가 full이 아닐 수 있으므로 정확하게 딱 몇개다라고 구하는게 아니라 최대 x개 필요하다고 계산하는 방식이다.  

위 사진들로 확인해보면  
높이가 2인 트리는 노드의 갯수가 8이므로 사용하지 않는 0번 index를 제외하면 7개의 노드가 필요했고  
높이가 3인 트리는 노드의 갯수가 16이고 index 0을 제외한 15칸 중 포화이진트리가 아니라서 15칸 모두 사용하진 않았지만 9칸을 사용하게되는 방식이다.  

#### 정리하면
크기가 N인 배열은  
- 트리의 높이 = CEIL(log<sub>2</sub>N)
- 트리의 크기 = 1 << (높이 + 1)
위 두 공식을 이용해서 트리 구현에 필요한 공간을 설정할 수 있다.  
배열의 크기 * 4로 대충 설정하고 쓰는 경우도 많다고 하니 혹시나 보게되면 알아차리면 될 듯 하다.  



## 4. 세그먼트 트리 구현

C++기준으로는 vector에 재귀를 사용해서 구현한다.  
재귀의 매개변수로 (현재노드번호, 시작범위, 마지막범위)를 사용한다.  
재귀의 첫 호출이라면  
- 현재노드번호 : index 0은 사용하지 않으므로 첫 호출은 1로 설정한다.
- 시작범위 : 배열의 시작범위이므로 0으로 설정한다.
- 마지막범위 : 배열의 마지막범위이므로 N-1로 설정한다.
즉 (1, 0, N - 1)로 재귀를 시작한다.

트리를 만드는 알고리즘 구성은
1) 주어진 범위를 반으로 나눈다.
2) 나눠진 2개의 범위 중 왼쪽범위에 대한 재귀를 호출한다.
3) 나눠진 2개의 범위 중 오른쪽범위에 대한 재귀를 호출한다.
4) 자식노드 2개의 값을 구했다면 두 값의 합이 자신의 값이 된다.
5) 위의 과정을 반복한다.

#### 자세한 설명
예를들어 `arr[] = { 1, 2, 3, 4, 5 };`일 때

###### 초기호출)
첫 재귀호출은 (1, 0, 4)이 된다.  

###### 알고리즘 1)
에서 범위가 5 / 2로 2가 되므로 이제 왼쪽범위는 0 ~ 2이고 오른쪽범위는 3~4이다.  

###### 알고리즘 2)
왼쪽자식노드는 현재노드번호 * 2이므로 재귀호출은 (2, 0, 2)가 된다.  
여기서 또 다음 왼쪽재귀는 (4, 0, 1)이 될것이고 그 다음은 (8, 0, 0)이 될 것이다.  
이때 `시작범위 == 마지막범위`가 되는때에 `SegmentTree[현재노드번호] = 배열[시작범위]`로 값을 설정한 후 재귀를 종료한다.  
여기선 `SegmentTree[8] = arr[0];`이 된다.

###### 알고리즘 3)
오른쪽자식노드는 현재노드번호 * 2 + 1이고 (8, 0, 0)에서 끝난 후 오른쪽 범위를 검사하므로 (9, 1, 1)이 된다.
이 또한 `시작하는 범위 == 끝나는 범위`이므로 `SegmentTree[9] = arr[1]`로 설정된다.

###### 알고리즘 4)
트리의 8번과 9번의 값을 구했으니 4번의 값은 두 값의 합이 된다.

###### 알고리즘5) 
위 재귀가 반복된다.

#### 구현 코드
```C++
#include <vector>

std::vector<int> arr{ 1, 2, 3, 4, 5 };
std::vector<int> SegmentTree;

int Make_SegmentTree(int Node, int Start, int End)
{
    if (Start == End) return SegmentTree[Node] = arr[Start];

    int Mid = (Start + End) / 2;
    int Left_Result = Make_SegmentTree(Node * 2, Start, Mid);
    int Right_Result = Make_SegmentTree(Node * 2 + 1, Mid + 1, End);
    SegmentTree[Node] = Left_Result + Right_Result;

    return SegmentTree[Node];
}

int main(void)
{
    int N = arr.size();

    int Tree_Height = (int)ceil(log2(N));
    int Tree_Size = (1 << (Tree_Height + 1));
    SegmentTree.resize(Tree_Size);
    Make_SegmentTree(1, 0, N - 1);
}
```



## 5. 세그먼트 트리 탐색

트리를 탐색할때 3가지 경우의 수가 있다.  
1) 현재 탐색하는 범위에 찾고자 하는 범위가 완전히 속하는 경우
2) 현재 탐색하는 범위와 찾고자 하는 범위가 전혀 다를 경우
3) 현재 탐색하는 범위에 찾고자 하는 범위가 일부만 속하는 경우(걸쳐있는 경우)

![[Pasted image 20240323133243.png|300x300]]
`arr[] = { 1, 2, 3, 4, 5 };`일 때 

#### 경우의 수 1)
배열 index 0 ~ 2의 구간합을 구한다면 위 사진에서 2번노드의 값인 6을 그대로 return하면 된다.

#### 경우의 수 2)
배열 index 3 ~ 4의 구간합을 구한다면 root에서 시작해서 왼쪽먼저 확인한다고 할 때 왼쪽노드는 배열의 index 0 ~ 2의 합이므로 범위가 전혀 다르다.  
이 경우 그냥 return하고 다음 탐색을 한다.

#### 경우의 수 3)
배열 index 2 ~ 3의 구간합을 구한다면 왼쪽서브트리와 오른쪽서브트리에 걸쳐있으므로 계속 아래로 내려가며 탐색해서 원하는 구간이 나오면 그 값을 더해서 리턴한다.  

