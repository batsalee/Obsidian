# 완전탐색, 백트래킹

## 완전탐색 알고리즘이란?

완전탐색은 가능한 모든 경우의 수를 다 체크해서 정답을 찾는 방법  
무식하게 푼다는 의미인 Brute-Force(브루트 포스)라고도 불림  
근데 사실상 브루트포스는 완전탐색의 여러 종류 중 하나라고 이해하는게 더 나을 듯 함  

완전탐색은 모든 경우의 수를 다 확인하므로 N의 크기가 너무 크면 비효율적이게 되므로 N의 크기가 작을때 완전탐색을 사용한다.  

브루트포스의 대표적인 예시로 네자리수 비밀번호를 찾을때 0000 ~ 9999를 모두 입력해보는 방식이 있다  
하지만 문제해결 알고리즘을 사용할때에는 알고리즘이 효율적인지를 고려해야 하므로 브루트포스는 항상 좋은 방법이 아니다.  
브루트포스 외에 더 효율적인 방법이 있다면 해당 방법을 사용하는것이 좋다.  

#### 대표적인 완전탐색 알고리즘
1) Brute Force : 반복문, 조건문을 활용해 모든 경우를 테스트하는 방법
2) 순열(Permutation) : N개의 원소 중 R개의 원소를 중복허용없이 다른 순서로 나열하는 방법
3) 재귀 호출(Recursive)
4) 비트마스크 : 2진수 표현기법을 활용하는 방법
5) DFS : 그래프 완전탐색 방법


## 1. Brute Force

반복문, 조건문을 활용해 모든 경우를 테스트하는 방법
네자리수 비밀번호를 찾는다면 0000 ~ 9999를 모두 입력해보는 방식
```C++
#include <iostream>

void bruteForce(const int pw)
{
	for (int i = 0; i < 10000; i++) {
		if (pw == i) {
			printf("%04d", i);
			break;
		}
	}
}

int main() 
{
	const int password = 1234;
	bruteForce(password);

	return 0;
}
```


# 2. 순열(Permutation)

#### 1) 순열이란
N개의 원소 중 R개의 원소를 중복 허용 없이 나열하며 순서가 다르다면 다른 수열로 연산하는 방법  
예를들어 수열 { 1, 2, 3 }이 있다면 이 수열을 { 1, 2, 3 }과 { 3, 2, 1 }로 보는것의 차이가 필요한 경우 순열을 사용한다.  

#### 2) 순열의 특징
- N개의 서로 다른 데이터가 수열로 이루어져있다면 순열의 전체 가지수는 N!가지가 됨  
- 같은 데이터로 이루어진 수열이지만 그 순서에 의미가 있고 바로 이전/다음 수열을 알 수 있음  
- 수열의 i번째 값부터 모두 내림차순이라면 해당 순열은 1번째값~i번째값으로 시작하는 순열 중 최종순열
- 수열의 i번째 값부터 모두 오름차순이라면 해당 순열은 1번째값~i번째값으로 시작하는 순열 중 최초순열

자세히 설명해보자면 수열 { 1, 2, 3 }을 순열로 나열한다면  
```
{ 1 2 3 } // 최초순열은 오름차순
{ 1 3 2 }
{ 2 1 3 }
{ 2 3 1 }
{ 3 1 2 }
{ 3 2 1 } // 최종순열은 내림차순
```
가지수가 3!인 6가지 종류가 나오며 최초순열을 오름차순이며 최종순열은 내림차순이 된다.  
또한 1로 시작하는 순열 중 최초순열은 { 1 2 3 }이 되므로 1의 뒷부분부터 오름차순이고  
1로 시작하는 순열 중 최종순열은 { 1 3 2 }가 되므로 1의 뒷부분부터 내림차순이다.  

#### 3) 순열을 만드는 알고리즘
우선 감사하게도 STL algorithm 헤더에 순열 알고리즘이 구현되어 있다.  
```C++
/*
조건 1) 오름차순으로 정렬된 컨테이너로만 사용 가능
조건 2) default값이 오름차순으로 된 순열 생성이다
조건 3) 중복된 원소가 있다면 결과에서는 한번만 출력함
        예를들어 수열이 { 0 0 1 }이라면 
        6가지 순열이 아닌 중복 제외된 {0 0 1}, {0 1 0}, {1 0 0} 3가지만 만들어줌

bool next_permutation (BidirectionalIterator first, BidirectionalIterator last);
bool next_permutation (BidirectionalIterator first, BidirectionalIterator last, Compare comp);
다음 순열이 존재하면 해당 컨테이너를 다음 순열로 만들고 true를 리턴
다음 순열이 없다면 false를 리턴

이전 순열은 prev_permutation
*/

#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    vector<int> vec{1, 2, 3}; 
    sort(v.begin(), v.end());
 
    do {
        for (int v : vec) {
            cout << v << ' ';
		}
        cout << endl;
    } while (next_permutation(v.begin(), v.end()));
    
    return 0;
}
```

원리를 살펴보자면 1 ~ 10으로 구성된 수열이 있다면  
```
...
{ 3 4 5 10 9 8 7 6 2 1 } // 3 4 5 로 시작하는 순열 중 최종순열
{ 3 4 6 1 2 5 7 8 9 10 } // 3 4 6 로 시작하는 순열 중 최초순열
...
```
위 모습처럼 되므로 `i = 3`이라면 최종순열의 바로 다음순열인 최초수열을 만드는 방법은  
1 ~ (i - 1)번째 순열까지는 그대로 두고(위에서는 3 4까지)  
i번째 값을 (i + 1) ~ N중 i보다는 크지만 가장 작은 값과 교환하고 (i + 1) ~ N은 오름차순으로 만들면 된다  
위 규칙을 통해 이전/다음 순열을 구하거나 모든 순열을 완전탐색으로 구하는 로직을 구현할 수 있으나 해당 알고리즘은 N개의 숫자에 대한 순열을 모두 구하게 만드는 알고리즘이며 시간복잡도가 O(N!)으로 너무 높으므로 주어진 N의 크기가 아주 작을때만 사용해볼만하다.
