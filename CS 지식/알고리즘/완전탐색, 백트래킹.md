# 완전탐색, 백트래킹

## 완전탐색 알고리즘이란?

완전탐색은 가능한 모든 경우의 수를 다 체크해서 정답을 찾는 방법  
무식하게 푼다는 의미인 Brute-Force(브루트 포스)라고도 불림  
근데 사실상 브루트포스는 완전탐색의 여러 종류 중 하나라고 이해하는게 더 나을 듯 함  

완전탐색은 모든 경우의 수를 다 확인하므로 N의 크기가 너무 크면 비효율적이게 되므로 N의 크기가 작을때 완전탐색을 사용한다.  

브루트포스의 대표적인 예시로 네자리수 비밀번호를 찾을때 0000 ~ 9999를 모두 입력해보는 방식이 있다  
하지만 문제해결 알고리즘을 사용할때에는 알고리즘이 효율적인지를 고려해야 하므로 브루트포스는 항상 좋은 방법이 아니다.  
브루트포스 외에 더 효율적인 방법이 있다면 해당 방법을 사용하는것이 좋다.  

#### 대표적인 완전탐색 알고리즘
1) Brute Force : 반복문, 조건문을 활용해 모든 경우를 테스트하는 방법
2) 순열(Permutation) : N개의 원소 중 R개의 원소를 중복허용없이 다른 순서로 나열하는 방법
3) 재귀 호출(Recursive)
4) 비트마스크 : 2진수 표현기법을 활용하는 방법
5) DFS : 그래프 완전탐색 방법


## 1. Brute Force

반복문, 조건문을 활용해 모든 경우를 테스트하는 방법
네자리수 비밀번호를 찾는다면 0000 ~ 9999를 모두 입력해보는 방식
```C++
#include <iostream>

void bruteForce(const int pw)
{
	for (int i = 0; i < 10000; i++) {
		if (pw == i) {
			printf("%04d", i);
			break;
		}
	}
}

int main() 
{
	const int password = 1234;
	bruteForce(password);

	return 0;
}
```


# 2. 순열(Permutation)

#### 1) 순열이란
N개의 원소 중 R개의 원소를 중복 허용 없이 나열하며 순서가 다르다면 다른 수열로 연산하는 방법  
예를들어 수열 { 1, 2, 3 }이 있다면 이 수열을 { 1, 2, 3 }과 { 3, 2, 1 }로 보는것의 차이가 필요한 경우 순열을 사용한다.  

#### 2) 순열의 특징
- N개의 서로 다른 데이터가 수열로 이루어져있다면 순열의 전체 가지수는 N!가지가 됨  
- 같은 데이터로 이루어진 수열이지만 그 순서에 의미가 있고 바로 이전/다음 수열을 알 수 있음  
- 수열의 i번째 값부터 모두 내림차순이라면 해당 순열은 1번째값~i번째값으로 시작하는 순열 중 최종순열
- 수열의 i번째 값부터 모두 오름차순이라면 해당 순열은 1번째값~i번째값으로 시작하는 순열 중 최초순열

자세히 설명해보자면 수열 { 1, 2, 3 }을 순열로 나열한다면  
```
{ 1 2 3 } // 최초순열은 오름차순
{ 1 3 2 }
{ 2 1 3 }
{ 2 3 1 }
{ 3 1 2 }
{ 3 2 1 } // 최종순열은 내림차순
```
가지수가 3!인 6가지 종류가 나오며 최초순열을 오름차순이며 최종순열은 내림차순이 된다.  
또한 1로 시작하는 순열 중 최초순열은 { 1 2 3 }이 되므로 1의 뒷부분부터 오름차순이고  
1로 시작하는 순열 중 최종순열은 { 1 3 2 }가 되므로 1의 뒷부분부터 내림차순이다.  

#### 3) 순열을 만드는 알고리즘
우선 감사하게도 STL algorithm 헤더에 순열 알고리즘이 구현되어 있다.  
```C++
/*
조건 1) 오름차순으로 정렬된 컨테이너로만 사용 가능
조건 2) default값이 오름차순으로 된 순열 생성이다
조건 3) 중복된 원소가 있다면 결과에서는 한번만 출력함
        예를들어 수열이 { 0 0 1 }이라면 
        6가지 순열이 아닌 중복 제외된 {0 0 1}, {0 1 0}, {1 0 0} 3가지만 만들어줌

bool next_permutation (BidirectionalIterator first, BidirectionalIterator last);
bool next_permutation (BidirectionalIterator first, BidirectionalIterator last, Compare comp);
다음 순열이 존재하면 해당 컨테이너를 다음 순열로 만들고 true를 리턴
다음 순열이 없다면 false를 리턴

이전 순열은 prev_permutation
*/

#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    vector<int> vec{1, 2, 3}; 
    sort(v.begin(), v.end());
 
    do {
        for (int v : vec) {
            cout << v << ' ';
		}
        cout << endl;
    } while (next_permutation(v.begin(), v.end()));
    
    return 0;
}
```

원리를 살펴보자면 1 ~ 10으로 구성된 수열이 있다면  
```
...
{ 3 4 5 10 9 8 7 6 2 1 } // 3 4 5 로 시작하는 순열 중 최종순열
{ 3 4 6 1 2 5 7 8 9 10 } // 3 4 6 로 시작하는 순열 중 최초순열
...
```
위 모습처럼 되므로 `i = 3`이라면 최종순열의 바로 다음순열인 최초수열을 만드는 방법은  
1 ~ (i - 1)번째 순열까지는 그대로 두고(위에서는 3 4까지)  
i번째 값을 (i + 1) ~ N중 i보다는 크지만 가장 작은 값과 교환하고 (i + 1) ~ N은 오름차순으로 만들면 된다  
위 규칙을 통해 이전/다음 순열을 구하거나 모든 순열을 완전탐색으로 구하는 로직을 구현할 수 있으나 해당 알고리즘은 N개의 숫자에 대한 순열을 모두 구하게 만드는 알고리즘이며 시간복잡도가 O(N!)으로 너무 높으므로 주어진 N의 크기가 아주 작을때만 사용해볼만하다.  
통상적으로 O(N!)은 N이 11 ~ 12일때 1초내외 걸리므로 고려해서 사용해보면 될 듯 하다.  

C++과 Python에서는 순열함수를 제공하지만 Java에서는 제공하지 않는다고 한다.  
직접 구현해보려면 아래의 로직대로 해보면 될 듯 하다.  
```
1. A[i-1] <= A[i]를 만족하는 i 중 가장 큰 값을 찾는다.
(혹은 뒤에서부터 찾는 경우 A[i-1] >= A[i] 중 가장 작은 i를 찾는다.)
현재 i값을 기준으로 이후는 모두 내림차순으로 되는 경우를 찾는 다는 것이다. 현재 기준 최종 순열을 찾음
A배열을 보면 A[i-1] < A[i]가 되는 가장 큰 i는 6인 3번째(0부터 시작)이다. 즉, i=3이 된다.

2. j >= i 중, A[j] > A[i-1]을 만족하는 가장 큰 j의 값을 찾는다.
현재가 최종 순열 상태이므로 i-1번째 숫자를 변경하여 최초 순열을 찾아야 한다.
A배열을 기준으로 i-1번째 숫자는 3으로 3보다 큰 경우는 6, 5, 4이나 그 중 j 값이 가장 큰 경우는 4이다.

3. A[i-1]과 A[j]를 Swap한다.
i-1인 2번째 숫자 3과 j인 5번째 숫자 4를 변경한다. A 배열은 다음과 같이 변경된다.
A={7, 2, 4, 6, 5, 3, 1}

4. i이후의 순열을 모두 뒤집는다.
최초 순열 상태로 만들어야 하므로 i번째부터는 오름차순으로 만들어야 한다. A 배열은 다음과 같이 변경된다.
A={7, 2, 4, 1, 3, 5, 6}
      
출처 : https://hongjw1938.tistory.com/78
```


## 3. 재귀 호출(Recursive)

재귀는 말 그대로 자기 자신을 호출하는 것을 의미한다.  
주로 각 원소가 포함되거나 or 포함되지 않거나 두가지 선택을 가질때 사용한다.  

다만 반복문으로 될 것 같으면 무조건 반복문을 사용하는게 우선이다.  
함수를 여러번 호출하는것은 코스트가 크고 함수 콜 스택이 깊어지면 프로그램이 죽을 수도 있다.  
반복문으로 안될것같거나 너무 복잡해지거나 어떤 행위를 반복은 하는데 매개변수만 변경해서 넘기면 될 것 같을때 사용한다.  

#### 예시 1)
예시1) 만들고자 하는 부분집합 S'가 있을때 S' = { } 부터 시작해서 각 원소에 대해 해당 원소가 포함이 된다면 S'에 넣고 재귀함수를 돌리고, 포함이 되지 않는다면 S'를 그대로 재귀함수에 넣는 방식

#### 예시2)
숫자 1, 2, 3이 써있는데 세명의 사람이 그 숫자 중 하나를 선택하는 모든 경우의 수  
1 1 1이 될수도 있고 1 1 2나 1 3 2나 3 1 2 등 각자 선택한 숫자의 모든 경우의 수를 반복문으로 쓴다면  
3중 for문이 되겠지만 숫자가 10개라면 O(N^10)이므로 가치없는 알고리즘이 됨  

예시 2의 일반적인 알고리즘 틀은 아래 코드와 같음
```C++
int arr[3];

void getRecursion(int idx)
{
    if(idx > 2) {
        for(int i = 0; i < 3; i++) {			// 여기서의 3은 출력할 숫자의 갯수
            std::cout << arr[i] << ' ';
        }
        std::cout << '\n';
    }
    
    else {
        for(int i = 1; i <= 3; i++) {			// 여기서의 1과 3은 출력할 숫자의 숫자 범위
            arr[idx] = i;
            getRecursion(idx + 1);
        }
    }
}

출처 : https://seminzzang.tistory.com/100
자세한 동작 방식은 위 사이트에서 볼 수 있음
```