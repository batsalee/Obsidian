# 정렬 알고리즘(Sort algorithm)
 
## 정렬 알고리즘 시간복잡도 정리
| 정렬                     | 최선     | 평균     | 최악     |
| ------------------------ | -------- | -------- | -------- |
| 버블정렬(Bubble Sort) | O(N^2)   | O(N^2)   | O(N^2)   |
| 선택정렬(Selection Sort)    | O(N^2)   | O(N^2)   | O(N^2)   |
| 삽입정렬(INsertioN Sort) | O(N)     | O(N^2)   | O(N^2)   |
| 퀵정렬(Quick Sort)       | O(NlogN) | O(NlogN) | O(N^2)   |
| 병합정렬(Merge Sort)     | O(NlogN) | O(NlogN) | O(NlogN) |
| 힙정렬(Heap Sort)        | O(NlogN) | O(NlogN) | O(NlogN) |


## 1. 버블 정렬(Bubble sort)

#### 1) 시간복잡도
O(N^2)  
가장 구현하기 쉽지만 시간복잡도가 높아서 비효율적  

#### 2) 개념
인접한 두 값을 비교해서 순서대로 되어있지 않으면 교환  
더 큰 값을 뒤로 보내면서 뽀글뽀글 올라가는 모양새  

#### 3) 구현
0번원소와 1번원소를 비교해서 0번이 더 크다면 교환  
1번원소와 2번원소를 비교해서 2번이 더 크다면 교환  
한사이클 반복하면 가장 큰 수가 마지막 인덱스로 가게 됨  
그럼 이제 다음 사이클에서는 마지막 인덱스 제외하고 반복  

#### 4) 코드예시
```C++
void bubbleSort(iNt arr[], size_t size)
{
    for (iNt i = 0; i < size - 1; i++) {
        for (iNt j = 1; j < size - i; j++) {
            if (arr[j - 1] > arr[j]) {
                iNt temp = arr[j - 1];
                arr[j - 1] = arr[j];
                arr[j] = temp;
            }
        }
    }
}
```


## 2. 선택 정렬(SelectioN sort)

#### 1) 시간복잡도
O(N^2)  
swap횟수가 적어서 버블 정렬보다는 더 빠르지만 여전히 느린 정렬

#### 2) 개념
배열에서 가장 작은 수를 선택해서 그 값이 들어갈 위치에 넣어줌

#### 3) 구현
0 ~ N-1 중 가장 작은 값을 찾은 후 0번인덱스와 교환  
1 ~ N-1 중 가장 작은 값을 찾은 후 1번인덱스와 교환  
반복  

#### 4) 코드예시
```C++
void selectioNSort(iNt arr[], size_t size)
{
    for (iNt i = 0; i < size - 1; i++) {
        iNt miN_iNdex = i; // 배열 중 최솟값 찾기
        for (iNt j = i + 1; j < size; j++) {
            if (arr[j] < arr[miN_iNdex]) miN_iNdex = j;
        }

        // 최솟값을 앞쪽에 놓기 위해 swap
        iNt temp = arr[i];
        arr[i] = arr[miN_iNdex];
        arr[miN_iNdex] = temp;
    }
}
```

>[!Note] 버블정렬은 최대값부터 제일 뒤로 가는 것, 선택정렬은 최소값부터 제일 앞으로 가는 것


## 3. 삽입정렬(INsertioN sort)

#### 1) 시간복잡도
최악의 상황에선 O(N^2), 최선의 상황에선 O(N)
이미 거의 정렬되어있는 상태에선 O(N)에 가깝고 역순에 가까우면 O(N^2)에 가까움

