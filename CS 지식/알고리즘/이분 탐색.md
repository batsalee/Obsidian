# 이분 탐색

## 1. 개념

이분탐색(Binary Search)  
이분탐색 혹은 이진탐색이라고 불리며 ==정렬된== 배열에서 원하는 값의 존재여부(혹은 위치)를 찾는 알고리즘  
반드시 정렬된 상태에서만 사용 가능하며 탐색을 수행할때마다 검사 범위가 절반으로 줄어들기 때문에 시간복잡도는 O(logN)이다  

![[Pasted image 20240114231806.png]]


## 2. 사용 방법

배열의 시작점을 low, 중간점을 mid, 배열의 끝점을 high 정하고 시작  
1) 검사 범위에서 mid값이 찾고자 하는 값(target)과 같은지 확인
2) `if(arr[mid] == target)`이라면 mid를 반환
3) `if(arr[mid] < target)`이라면 검사 범위를 더 큰쪽으로 옮겨야 하므로 low = mid + 1;
4) `if(arr[mid] > target)`이라면 검사 범위를 더 작은쪽으로 옮겨야 하므로 high = mid - 1;
5) 1~4의 과정을 반복하다가 `arr[mid] == target`이라면 mid를 반환
6) 만약 low > high라면 배열에 target이 없는것이므로 `return -1;`


## 3. 사용 예시

#### 1) 반복문으로 구현
```C++
#include <iostream>
#include <vector>

int binarySearch(std::vector<int>& arr, int low, int high, int target) {
	while (low <= high) {
		int mid = (low + high) / 2;

		if (target == arr[mid]) return mid; // 값을 찾았다면 해당 값의 index 반환
		else if (target < arr[mid]) high = mid - 1; // 찾는 값이 더 작으면 검사 범위를 작은 쪽으로
		else if (target > arr[mid]) low = mid + 1; // 찾는 값이 더 크면 검사 범위를 큰 쪽으로
	}
	return -1; // 마지막까지 못찾는다면 -1 반환
}

int main()
{
	std::vector<int> array{ 1, 3, 5, 7, 9, 11, 13 };

	std::cout << "7의 인덱스 : " << binarySearch(array, 0, array.size() - 1, 7) << '\n';
}
```

#### 2) 재귀로 구현
```C++
#include <iostream>
#include <vector>

int binarySearch(std::vector<int>& arr, int low, int high, int target) {
	if (low > high) return -1;

	int mid = (low + high) / 2;

	if (target == arr[mid]) return mid;
	else if (target > arr[mid]) return binarySearch(arr, mid + 1, high, target);
	else if (target < arr[mid]) return binarySearch(arr, low, mid - 1, target);
}

int main()
{
	std::vector<int> array{ 1, 3, 5, 7, 9, 11, 13 };

	std::cout << "7의 인덱스 : " << binarySearch(array, 0, array.size() - 1, 7) << '\n';
}
```

#### 3) C++ STL로 구현
```C++
// index 출력은 안되고 존재 유무만 true/false로 return
// algorithm 헤더 include

#include <iostream>
#include <vector>
#include <algorithm>

int main()
{
	std::vector<int> array{ 1, 3, 5, 7, 9, 11, 13 };

	bool isFound = binary_search(array.begin(), array.end(), 7);
	std::cout << std::boolalpha << isFound << '\n';

	return 0;
}
```


## 4. 이분탐색을 이용한 C++ STL 함수

위의 binary_search외에도 이분탐색을 이용한 STL함수들이 있다  
- lower_bound : 찾고자 하는 값 ==이상==이 처음 나타나는 iterator 반환
- upper_bound : 찾고자 하는 값 ==초과==이 처음 나타나는 iterator 반환

예를들어 { 1, 2, 4, 4, 6, 7 }에 값 4로 위 함수들을 사용한다면  
lower_bound는 4가 처음 나타나는 index인 2를 return  
upper_bound는 4 초과가 처음 나타나는 index인 4를 return  

>[!warning] 두 함수 또한 이분탐색을 기반으로 하므로 정렬된 배열에만 사용할 수 있다.

#### 이분탐색을 이용한 count
배열 안에서 값 k의 갯수를 구하라고 한다면 count로 for문 돌리면 O(N)이 된다.

반면 lower_bound와 upper_bound를 활용해서 upper - lower를 해주면  
해당 배열에 들어있는 k의 갯수를 알 수 있으며 O(logN)이 되므로 더 유리하다.
```C++
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
	std::vector<int> array { 1, 2, 4, 4, 6, 7 };

	int target = 4;
	int l = lower_bound(array.begin(), array.end(), target) - array.begin();
	int u = upper_bound(array.begin(), array.end(), target) - array.begin();
	std::cout << l << '\n'; // 2
	std::cout << u << '\n'; // 4

	// 중복값을 구하는 문제라면
	std::cout << "target의 갯수는 " << u - l << "개 입니다.\n";
	
	return 0;
}
```

다만 이미 정렬되어 있는 배열에 count할때에나 O(logN)이고  
굳이 배열을 정렬 후에 사용한다면 정렬을 위해 O(NlogN)에 추가로 O(logN)이 되므로  
O(NlogN)은 그냥 count하는 O(N)보다도 못하므로 이미 정렬된 채로 주어질때만 사용하면 좋다.




※ 참고 문헌
[https://m42-orion.tistory.com/69](https://m42-orion.tistory.com/69)
[https://www.geeksforgeeks.org/binary-search/](https://www.geeksforgeeks.org/binary-search/)
[https://velog.io/@junsj119/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89Binary-Search](https://velog.io/@junsj119/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89Binary-Search)