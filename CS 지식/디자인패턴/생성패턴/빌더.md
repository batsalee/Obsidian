# 빌더


## 1. 빌더 패턴(Builder Pattern)

빌더 패턴(Builder Pattern)이란 객체의 생성자에 들어갈 매개변수를 메서드로 하나하나 받은 후 마지막에 통합해서 빌드하여 객체를 생성하는 방식으로 생성 과정과 표현 방법을 분리해서 다양한 구성의 인스턴스를 만드는 생성패턴이다.

예시로는 수제 햄버거를 주문할때 빵을 햄버거 번으로 할지 식빵으로할지 등등 주문하는 사람이 정하고, 
들어가는 재료도 상추를 넣을지 토마토를 넣을지, 치즈를 넣을지 말지 등등 모두 주문하는 사람이 마음대로 결정한다.  

이처럼 속재료들을 선택적으로 유연하게 받아 다양한 타입의 인스턴스를 생성할 수 있기에 클래스의 선택적 매개변수가 많은 상황에서 유용하게 사용된다.


## 2. 빌더 패턴이 없다면

빌더 패턴이 없을때 수제 햄버거를 만든다면 어떻게 해야할까?

#### 1) 점층적 생성자 패턴
- 빵만 있는 버거를 위한 생성자
- 빵과 패티가 있는 버거를 위한 생성자
- 빵과 패티와 치즈가 있는 버거를 위한 생성자
- 빵과 패티와 치즈와 상추가 있는 버거를 위한 생성자
- .....

이런식으로 모든 경우의 생성자를 다 만드는 것이 점층적 생성자 패턴이다.
```C++
class Hamburger {
private:
    // 필수 매개변수
    int bun;
    int patty;

    // 선택 매개변수
    int cheese;
    int lettuce;
    int tomato;
    int bacon;

public:
    Hamburger(int bun, int patty, int cheese, int lettuce, int tomato, int bacon) {
        this->bun = bun;
        this->patty = patty;
        this->cheese = cheese;
        this->lettuce = lettuce;
        this->tomato = tomato;
        this->bacon = bacon;
    }

    Hamburger(int bun, int patty, int cheese, int lettuce, int tomato) {
        this->bun = bun;
        this->patty = patty;
        this->cheese = cheese;
        this->lettuce = lettuce;
        this->tomato = tomato;
    }

    Hamburger(int bun, int patty, int cheese, int lettuce) {
        this->bun = bun;
        this->patty = patty;
        this->cheese = cheese;
        this->lettuce = lettuce;
    }

    Hamburger(int bun, int patty, int cheese) {
        this->bun = bun;
        this->patty = patty;
        this->cheese = cheese;
    }

    Hamburger(int bun, int patty) {
        this->bun = bun;
        this->patty = patty;
    }
};

int main()
{	
	Hamburger hamburger1(2, 1, 2, 4, 6, 8); // 모든 재료가 있는 햄버거
	Hamburger hamburger2(2, 1, 1); // 빵과 패티 치즈만 있는 햄버거
	Hamburger hamburger3(2, 1, 0, 0, 0, 6); // 빵과 패티 베이컨만 있는 햄버거

	return 0;
}
```
코드만 봐도 알겠지만 클래스의 인스턴스들이 많으면 많을수록 생성자에 들어갈 인자의 수도 늘어나고, 생성자의 갯수도 엄청나게 늘어나게 되고 코드의 복잡성뿐 아니라 사용하는 입장에서도 헷갈릴 경우가 많다.  

인자의 순서가 무엇인지 파악도 필요하며, 만약 빵과 베이컨만 있는 햄버거를 만든다면 매개변수를 (1, 0, 0, 0, 0, 1)처럼 써야하니 쓸데없이 0만 많이 넣게 된다.  

#### 2) 자바 빈(Java Beans) 패턴
위의 점층적 생성자 패턴을 보완하기 위해 만들어진 패턴으로 매개변수가 없는 생성자로 객체를 생성한 후 setter 메서드를 사용해 객체의 인스턴스들을 초기화해주는 방식
```C++
class Hamburger {
private:
    // 필수 매개변수
    int bun;
    int patty;

    // 선택 매개변수
    int cheese;
    int lettuce;
    int tomato;
    int bacon;

public:
    // 기본 생성자
    Hamburger() { }

    // setter 함수들
    void setBun(int bun) { this->bun = bun; }
    void setPatty(int patty) { this->patty = patty; }
    void setCheese(int cheese) { this->cheese = cheese; }
    void setLettuce(int lettuce) { this->lettuce = lettuce; }
    void setTomato(int tomato) { this->tomato = tomato; }
    void setBacon(int bacon) { this->bacon = bacon; }
};

int main()
{
    // 모든 재료가 있는 햄버거
    Hamburger hamburger1;
    hamburger1.setBun(2);
    hamburger1.setPatty(1);
    hamburger1.setCheese(2);
    hamburger1.setLettuce(4);
    hamburger1.setTomato(6);
    hamburger1.setBacon(8);

    // 빵과 패티 치즈만 있는 햄버거
    Hamburger hamburger2;
    hamburger2.setBun(2);
    hamburger2.setPatty(1);
    hamburger2.setCheese(2);

    // 빵과 패티 베이컨만 있는 햄버거
    Hamburger hamburger3;
    hamburger3.setBun(2);
    hamburger2.setPatty(1);
    hamburger3.setBacon(8);

	return 0;
}
```
이 방법은 점진적 생성자 방식에 비해 가독성이 좋은 편이며, 객체 매개변수를 자유롭게 조정할 수 있으니 유연한 객체생성이 가능하다. 하지만 이 방법도 일관성문제와 불변성문제가 나타난다.

##### - 일관성 문제
클래스에 주석으로 필수 매개변수라고 작성되어 있는 인스턴스처럼 필수로 값이 들어가야할 값이 있다면 값이 반드시 들어가야 하지만, 개발자의 실수로 생성자 호출 후 setBun(), setPatty() setter를 호출하지 않는다면 객체가 유효하지 않으며 일관성이 무너진 상태가 된다.

물론 필수 매개변수만 생성자 내부에서 초기화하고, 그 외의 매개변수들은 setter로 설정하는 방법도 가능하지만 아래의 불변성 문제가 남아있다.

##### - 불변성 문제
객체를 생성한 후 setter로 객체의 속성을 설정한 이후에도 setter함수들은 public으로 노출되어 있으므로 언제 어디서 setter메서드로 객체가 조작될지 알 수 없다.


## 3. 빌더 패턴을 쓴다면?

빌더 패턴은 위의 문제들을 해결하기 위해 별도의 Builder클래스를 만들고  
Builder클래스의 임시객체로 step-by-step으로 메소드를 호출한 후 값을 설정하고 다시 자기자신을 리턴하면서  
최종적으로 build()메소드를 사용해 하나의 인스턴스를 생성하여 리턴하는 패턴이다.
```C++
#include <iostream>
using namespace std;

class Student { // 만들고자 하는 객체는 Student 객체
private:
    int _id;
    string _name;
    string _grade;
    string _phoneNumber;

public:
    Student(int id, string name, string grade, string phoneNumber) {
        _id = id;
        _name = name;
        _grade = grade;
        _phoneNumber = phoneNumber;
    }

    void print() {
        cout << _id << ' ' << _name << ' ' << _grade << ' ' << _phoneNumber;
    }
};

class StudentBuilder { // Student의 정보를 때에따라 구현하기 위해 Builder클래스 구현
private: // 멤버 변수는 Student와 동일하게 구성
    int _id;
    string _name;
    string _grade;
    string _phoneNumber;

public: // setter메서드를 구현, 단 여기선 가독성과 기존의 setter와의 차이점을 부각하기 위해 set단어는 제외
    StudentBuilder id(int id) { // setID가 아닌 그냥 id로 써서 네이밍하는걸 추천한다.
        _id = id;
        return *this; // 이런식으로 계속해서 객체 자신을 반환함
    }

    StudentBuilder name(string name) {
        _name = name;
        return *this;
    }

    StudentBuilder grade(string grade) {
        _grade = grade;
        return *this;
    }

    StudentBuilder phoneNumber(string phoneNumber) {
        _phoneNumber = phoneNumber;
        return *this;
    }

    Student build() {
        return Student(_id, _name, _grade, _phoneNumber);
    }
};

int main()
{
    Student student = StudentBuilder() // 임시객체를 만들고
        .id(2016120091) // 임시객체로 이 함수를 호출하고, 함수가 또 객체 자신을 리턴
        .name("임꺽정") // 리턴된 객체로 또 함수를 호출
        .grade("Senior")
        .phoneNumber("010-5555-5555")
        .build(); // 마지막에 build함수 호출로 Student객체 리턴
	// 위처럼 자기 자신을 리턴하면서 연속적으로 메서드들을 호출하는걸 체이닝(Chaining)이라고 함

    student.print();

    return 0;
}
```