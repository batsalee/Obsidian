# 비트마스킹

## 1. 개념

비트마스킹 혹은 비트마스크라고 불리며 2진수를 이용하는 컴퓨터의 연산을 이용하여 비트(bit)연산을 통해서 집합에서 포함이 되는지/안되는지에 따라 생기는 부분집합들을 표현하는 방법론  

그러므로 완전탐색에서 문제에서 나올수 있는 모든 경우의 수가  
각각의 원소가 ==포함되거나 / 포함되지 않거나== 두가지 선택으로 구성되는 경우 유용하게 사용됨  

하지만 비트마스킹은 int형 숫자의 표기 가능비트에 한계가 있으므로 31개의 원소까지만가능하다는 한계가 있음(더 큰 자료형을 쓰면 상관없어지게 될 듯함)


## 2. 비트마스킹 사용 예시

원소가 5개인 집합의 모든 부분집합을 구하는 경우 어떤 집합의 부분집합은  
각 원소가 해당 부분집합에 포함되거나 / 포함되지 않는 두가지 경우만 존재함  

그러므로 5자리 이진수인 0 ~ 31을 이용해서 각 원소의 포함 여부를 체크 할 수 있음  
![[Pasted image 20231209024222.png|600x400]]  


## 3. 비트 연산

#### 1) 비트 연산의 종류
- AND 연산(&) : 둘 다 1이면 1
- OR 연산(|) : 둘 중 1개만 1이면 1
- NOT 연산(~) : 1이면 0으로, 0이면 1로
- XOR 연산(^) : 둘이 다르면 1, 같으면 0
- Shift 연산(<<, >>) : A << B라고 한다면 A를 좌측으로 B비트만큼 미는 것

| A   | B   | A & B | A \| B | ~A  | A ^ B |
| :-: | :-: | :-: | :-: | :-: | :-: |
| 0   | 0   | 0     | 0      | 1   | 0     |
| 0   | 1   | 0     | 1      | 1   | 1     |
| 1   | 0   | 0     | 1      | 0   | 1     |
| 1   | 1   | 1     | 1      | 0   | 0     |

> [!warning] 비트연산은 + - 연산보다 우선순위가 낮으므로 ()로 감싸줘야 한다

>[!note] NOT 연산에 대한 작은 설명
> 음수를 구할때 2의 보수를 구한 후 1을 더하면 그게 음수인데
> 그 말인즉슨 -value = ~value + 1이므로 ~value = -(value + 1)이 됨
> 즉 ~27은 -28이다라고 바로 계산할 수 있음

#### 2) 비트 연산 사용 예시

숫자 0과 1만 비트연산을 하는것이 아니라 모든 숫자에 사용 가능

모든 숫자는 2진수로 표현할 수 있으므로 

13은 1101

72는 1001000

으로 표현 가능

만약 13과 72를 비트연산 한다면 자릿수를 맞춰주기 위해 13의 앞에 0을 붙여줘서