# 코딩 습관들여야 할 것들

먼저 이 문서는 과거 C언어를 공부하던 당시 작성한 문서이므로  
현 시점에는 modern C++의 출시로인해 신경쓰지 않아도 되는 것들이 많이 포함되어 있음  
그래서 대부분 정리했고 남은 내용은 Today_Study 파일에 포함되었음

## 2. 동적할당

배열이나 구조체같은 큰 단위는 동적할당을 사용하자  
동적할당시 반드시 해제해줘야한다. 그리고 해제 후에는 포인터값을 0으로 초기화해준다.  
```C++ 
int* p = new int;
*p = 10;

delete p;
p = NULL;
```
만약 마지막에 p값을 return해서 다른 함수로 반환해준다면 그 받은 함수에서만 delete해주면 같은 주소값이니 한번으로 해제되므로 여러번 해제할 필요 없다.  

만약 생성자 내에서 동적할당을 사용하는 경우 소멸자에서 delete 해줘야한다.  
생성자 내에서 new가 나오면 자연스레 소멸자에 delete부터 쓰고 시작하기  
객체 자체를 동적할당으로 사용하는건 그냥 객체 다 쓰고나면 delete하면 되는거지만,  
생성자 내에서 특정 변수를 동적할당으로 사용하는 경우를 얘기하는 것임  

## 3. 포인터

포인터 변수는 항상 \\0으로 초기화한다. 포인터 변수를 사용하기 전에는 0이 아닌지 비교한다.  
```C++
int *p = null;
if(null != p) ~~~
```

포인터값은 16진수로 표시를 한다.  
그러므로 포인터는 0xffffffff 이런식으로 표시가 되며 포인터는 꼭 %x 혹은 hex를 이용해 표시하자  

포인터값은 컴파일러의 비트에 따라 4바이트/8바이트로 나뉜다.  
컴파일러가 32비트라면 4바이트로, 컴파일러가 64비트라면 8바이트로 사용된다.  
운영체제가 아니라 컴파일러임을 주의!  

## 5. 함수

값을 바꾸지 않는 함수는 const함수로 만든다  
void Print() const; 처럼 만들어서 값을 바꾸지 않음을 명시화해주는 것이 좋음  
그러므로 get함수류는 일단 다 const로 만들어주기  

배열을 인자로 넘겨주는 함수는 배열원소의 갯수도 같이 넘겨주는것이 좋을 수 있다.  
만약 `int ary[5]`가 선언되어 있으면 sizeof(ary)라고 하면 배열 전체의 크기인 20바이트가 나오지만  
`int *ap = ary;`일때 `sizeof(ap)`라고 하면 포인터변수인 ap의 크기이니까 포인터변수 크기인 4/8바이트가 나오므로 배열인자 갯수 코드를  `sizeof(ary)/sizeof(ary[0])` 처럼 사용하면 계산이 불가능해져버림  
그래서 호환성을 위해선 아예 애초에 매개변수로 배열인자갯수도 넘겨주게 코드를 짜는게 좋게됨  
`ary_prn(ary, sizeof(ary)/sizeof(ary[0]));` 이런식으로 배열명이랑 배열인자갯수 둘다 넘겨주는 코드 자주 보였던 이유가 위와 같은 이유.  

## 8. define

매크로의 경우 그대로 치환되는 것이니까 만약 `#define PLUS(x, y) x+y` 이런식으로 해버리면 공식같은 곳에 가서 연산순서때문에 더하기빼기나 곱하기 나누기 순서가 뒤바뀌어서 원하는 순서가 안나올 수 있는 위험이 있음.   
그래서 매크로로 공식을 만들땐 반드시 모든 인자에 괄호를 씌워서 우선순위를 설정해야 함  
`#define PLUS(x, y) ((x)+(y))` 이런식으로  
