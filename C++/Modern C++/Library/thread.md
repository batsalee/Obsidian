글 작성 다 하면 CS 폴더 만들어서 그쪽에 개념적인 내용들 넣고
여긴 라이브러리 내용만 넣어서 서로 링크따두기

# Thread

## 배경설명
과거의 CPU는 1개의 코어만 가졌었음  
즉 CPU가 한번에 하나의 일만 처리할 수 있었음  

하지만 User는 여러 프로세스를 동시에 실행하므로  
여러가지 일을 번갈아가면서 조금씩 실행해야 했음  

이를 위해 메모리에 올라와있는 현재 실행중인 프로그램들 중  
하나를 CPU로 가져와서 잠깐 처리해주고 또 다른 프로그램을 가져와서 처리함  
이떄 현재 실행중인 프로그램을 ==프로세스==라고 부름  

위처럼 메모리에서 값을 스위칭해주는 것을 ==컨텍스트 스위칭==(Context Switching)이라고 부름  
컨텍스트 스위칭은 CPU가 아니라 운영체제의 스케쥴러가 결정하는 것이고 CPU는 연산만 수행함  

CPU 코어에서 돌아가는 프로그램 단위를 ==쓰레드==(Thread)라고 부름  
즉 CPU 코어 하나에서 한번에 하나의 쓰레드를 실행함

프로세스는 최소 한개의 쓰레드로 이루어져 있고  
여러개의 쓰레드로 구성된 프로그램을 멀티쓰레드 프로그램이라고 부름  

프로세스와 쓰레드의 가장 큰 차이점은  
프로세스는 서로 독립적이라 서로 메모리를 공유하지 않음  
프로세스 A와 B가 있다면 A는 B의 메모리에 접근할 수 없고, B도 A의 메모리에 접근할 수 없음  
반면 한 프로세스 내에 있는 쓰레드들은 서로 같은 메모리를 공유함  
프로세스 A 안에 쓰레드 1과 쓰레드 2가 있다면 같은 변수에 접근이 가능함


## Thread가 필요한 이유
크게 하드웨어의 발전과 병렬 프로그램의 장점 2가지가 있음  

1) 하드웨어의 발전
시대가 발전하면서 CPU의 코어가 더 이상 한개가 아닌 여러개가 됐음  
인텔의 i5는 4개의 코어를, AMD 라이젠7은 8개의 코어를 사용함  

그런데 계속해서 단일쓰레드 프로그램을 사용한다면  
코어 1개만 일을 하고 나머지 코어들은 놀게 됨  

2) 병렬 프로그램의 장점
병렬 가능한 프로그램이라면 여러개의 쓰레드가 병렬진행하는것이 유리함  

예를들어 1부터 10000까지 더하는 프로그램을 만든다면  
```C++
for(int i = 1; i <= 10000; i++) {
	sum += i;
}
```
위 처럼 진행하게 될 텐데 만약 병렬 프로그래밍을 한다면  
쓰레드 1이 1부터 1000까지, 쓰레드 2가 1001부터 2000까지, ..., 쓰레드 10이 9001부터 10000까지  
더해준 후 마지막에 10개의 값만 합쳐주면 되므로 시간이 10분의 1 수준으로 줄어들게 됨  
즉 병렬화가 가능한 프로그램이라면 멀티쓰레드로 구성해서 여러개의 코어가 동시에 일하는것이 유리함  

또 다른 예시로 대기시간이 긴 작업들을 처리할 때 유리함  
만약 네트워크 작업을 하는 경우 Download 함수가 있다면  
쓰레드 1이 Download함수를 호출하면 Core 1에서 Download 작업을 처리한 후  
CPU는 네트워크 작업에 관여하지 않으므로 다운로드가 완료될때까지 그냥 대기하는 낭비가 발생함.  
이 떄 쓰레드 2가 또 Download함수를 호출한다면 Core 1이 그냥 대기하는 것이 아니라 쓰레드 2의 작업을 처리할 수 있음  

하지만 모든 프로그램이 병렬화가 가능한것은 아님  
예를들어 피보나치 수열을 구한다면 ``F(n) = F(n - 1) + F(n - 2)``를 수행해야 하는데  
F(n)을 알기 위해선 F(n - 1)과 F(n - 2)가 필요하므로  
병렬화를 해봤자 앞의 값을 모르니 진행이 불가능함
즉, 각 연산이 독립적이라면 병렬화가 유리하지만 각 연산이 의존적이라면 병렬화가 힘듬


## C++에서 Thread 사용
modern C++인 C++ 11이 나오기 전까진 C++에 쓰레드 관련 표준이 없었음  
그래서 각 플랫폼마다 구현 방법이 달랐음  
예를들어 Windows에서는 쓰레드를 만들기 위해 CreateThread 함수를 사용했었고  
Linux에서는 pthread_create함수를 사용했었음  

하지만 C++ 11버전에 쓰레드가 표준으로 추가되면서 사용하기 굉장히 쉬워짐  
```C++
#include <thread>

thread t1(func1); // thread 객체를 만들고 수행할 함수를 매개변수로 넣어줌

t1.join();  // join은 Thread가 실행을 종료하면 return하는 함수
			// 즉 t1이 종료하기 전까지 return하지 않으므로 계속 대기함
			// 출력해줄것이 있거나 결과를 확인해야 할 때 사용
or

t1.detach(); // Thread가 백그라운드에서 작동함
			 // 대기하는 것이 아닌 Thread는 Thread대로, 프로그램은 프로그램 대로 진행
			 // 출력이나 결과 확인이 필요 없을때 사용
```

사용예시)  
```C++
#include <thread>

void func1() {
	for (int i = 0; i < 10; i++) {
		std::cout << "쓰레드 1 작동중! \n";
	}
}

void func2() {
	for (int i = 0; i < 10; i++) {
		std::cout << "쓰레드 2 작동중! \n";
	}
}

void func3() {
	for (int i = 0; i < 10; i++) {
		std::cout << "쓰레드 3 작동중! \n";
	}
}

int main()
{
	thread t1(func1);
	thread t2(func2);
	thread t3(func3);

	t1.join();
	t2.join();
	t3.join();
}
```

운영체제의 스케쥴러가 언제 컨텍스트 스위칭을 할지는 마음대로라서  
위 코드를 실행하면 "쓰레드 1 작동중!"과 "쓰레드 2 작동중!"과 "쓰레드 3 작동중!"이  
순서대로 10번씩이 아닌 마음대로 출력됨


#### join이나 detach를 하지 않는다면?
위 코드에서 join()함수를 사용하지 않으면 쓰레드들의 작업이 끝나기도 전에 main함수가 종료됨  
Thread가 join이나 detach되지 않은 상태에서 소멸자가 호출된다면 예외가 발생함  
그러므로 join으로 대기시키거나, detach로 백그라운드에서 알아서 돌아가게 해줘야 함  


#### Thread에 인자 전달하기
Thread는 리턴값이 없으므로 결과값을 받아야 한다면 포인터 형태로 사용
```C++
void worker(int start, int end, int* result)
{...}

int main()
{
	int result = 0;
	thread t1(worker, 0, 10, &result);
	t1.join();
}
```
thread 객체 생성시 첫번째 인자로 함수명을, 두번째 인자부터 해당 함수의 매개변수들을 적어주면 됨  


#### 현재 작업중인 Thread 확인하기
`thread::id this_id = std::this_thread::get_id();`
위의 get_id()함수를 사용해서 현재 작업중인 thread의 id를 알 수 있음


#### Thread를 사용해서 출력할 때 주의사항
멀티쓰레드 프로그램에서 cout 사용시 문제가 발생할 수 있음
```C++
cout << "A의 값은 : " << a << " B의 값은 : " << b << " C의 값은 : " << c << endl;
```
위와 같은 출력문이 있다면 cout의 <<연산자를 수행 할때마다 실행되는 쓰레드가 바뀔 수 있음  
그래서 출력문이 여러 쓰레드들의 출력끼리 섞일 수 있고  
이를 해결하기 위해 printf를 사용하는것이 좋을 수 있음
``` C++
printf("A의 값은 : %d B의 값은 : %d C의 값은 : %d\n", a, b, c);
```


## 경쟁상태
여러 쓰레드들은 같은 메모리에 접근할 수 있음  
만약 현재 접속중인 유저의 수를 저장하는 user_count 변수에 10이 들어있을 때  
Thread 1이 `user_count += 1`을 하기 위해 user_count값을 얻어왔는데 + 1을 하기 직전  
Thread 2로 교체가 됐고 Thread 2도 마찬가지로  `user_count += 1`을 수행한다면  
Thread 1의 결과는 11이고, Thread 2의 결과도 11이므로  
user_count는 12가 되어야 정상이지만 11로 저장될 수 있음  

즉 문제가 일어나지 않으려면 `user_count += 1;`을 동시에 여러 쓰레드가 접근할 수 없게 해야 함  

#### 뮤텍스(mutex)
경쟁상태를 해결하기 위해 뮤텍스 객체를 사용함  
mutex란 상호 배제(mutual exclusion)이라는 단어에서 따옴
```C++
#include <mutex>  // mutex 를 사용하기 위해 필요
#include <thread>

void user(int& result, std::mutex& m) {
	m.lock();
	result += 1;
	m.unlock();	
}

int main() {
	int user_count = 0;
	std::mutex m;  // 우리의 mutex 객체

	std::thread t1(user, std::ref(user_count), std::ref(m));
	t1.join();

	std::thread t2(user, std::ref(user_count), std::ref(m));
	t2.join();

	std::cout << "user_count 최종 값 : " << user_count << '\n';
}
```
위처럼 mutex 객체를 이용해 lock해주고 하나의 thread만 사용 후 unlock해주는 구조로 사용  

```C++
m.lock();
result += 1;
m.unlock();	
```
위에서 m.lock()과 m.unlock()으로 감싸진 부분을 임계 영역(critical section)이라고 부르며  
한개의 쓰레드만이 접근 가능함

만약 unlock()을 빼먹으면 모든 쓰레드가 먼저 들어간 쓰레드를 기다리기만 하고 아무 연산도 못하다가 프로그램이 죽어버림  
이런 상황을 데드락(deadlock)이라고 부름

그런데 코드가 많이 길어진다면 마치 동적할당 후 free를 빼먹는 것 처럼  
프로그래머의 실수로 unlock()을 빼먹는 상황이 생길 수도 있음  
그런 이유로 뮤텍스토 unique_ptr처럼 사용 후 해제 패턴을 따르기 위해  
lock_guard를 사용 가능함

```C++
void user(int& result, std::mutex& m) {
	std::lock_guard<std::mutex> lock(m);
	result += 1;
}
```
위 코드처럼 사용하면 scope를 빠져 나가면서 lock객체가 소멸되므로  
lock_guard클래스의 소멸자가 호출되고 해당 소멸자에 unlock이 있어서 알아서 unlock됨  

#### 데드락
데드락 상황을 만들지 않기 위한 법칙들

try_lock() 함수
`if(m1.try_lock())`는 만약 m1이 lock을 할 수 있다면 lock을 하고 true를 리턴하고    
lock을 할 수 없다면 대기하지 않고 그대로 false를 리턴한다.  
이 함수를 이용해서false가 리턴된다면 다른 뮤텍스를 unlock시켜버리는 방식으로 특정 뮤텍스에 우선권을 줄 수 있음  

