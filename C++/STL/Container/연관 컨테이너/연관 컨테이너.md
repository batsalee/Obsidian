# 연관 컨테이너  

시퀀스 컨테이너인 vector, list, deque와 다르게 연관컨테이너는 key-value 구조를 가짐  
특정 키를 넣으면 이에 대응하는 값을 돌려줌  

1. [[set]] : 중복을 허용하지 않고, 값을 정렬해서 보관하며, 데이터 중에 키값이 존재하는가에 중점을 둠
2. [[map]] : 중복을 허용하지 않고, 값을 정렬해서 보관하며, 데이터 중에 키값이 존재한다면 그에 대응하는 값이 무엇인가에 중점을 둠
3. [[multiset]] : 
4. [[multimap]] : 
5. [[unordered_set]] : 
6. [[unordered_map]] : 

  
  
  
3) 멀티셋과 멀티맵  
멀티셋 멀티맵은 중복된 insert도 받음  
insert a b c d a b c 하면 내부에 a a b b c c d 로 저장됨  
멀티 맵의 경우   
m.insert(std::make_pair("박세웅", 2.23));  
m.insert(std::make_pair("박세웅", 3.59));  
하면 두개의 값이 다 들어있으니 m["박세웅"] = ? 식으로 접근이 불가능함  
둘 중 어디에 접근해야 할 지 알수 없으니  
그래서 []연산자를 제공하지 않음  
그럼 어떻게 접근하냐면   
auto range = m.equal_range("박세웅");  
for (auto itr = range.first; itr != range.second; ++itr) {  
std::cout << itr->first << " : " << itr->second << " " << std::endl;  
}  
처럼 equal_range에 키를 인자로 주면 대응하는 키들을 pair객체로 만들어서 리턴해줌  
그럼   
박세웅 : 2.23  
박세웅 : 3.59  
처럼 출력 가능  
  
4) unordered_set과 unordered_map  
- 정렬되지 않은 셋과 맵  
말그대로 정렬되어있지 않음. 값들을 넣고 출력해보면 순서가 막 뒤섞여서 랜덤하게 나옴  
unordered의 장점은 insert erase find가 엄청 빠름  
값을 해시함수로 해시해서 보관하는 방식이기 때문  
보통 안전하게 그냥 셋 맵을 쓰고, 최적화가 매우 중요한 경우에만 해시함수를 잘 설계해서 unordered를 사용  
  
5) 연관컨테이너 정리  
데이터의 존재 유무만 알면 된다 -> set  
중복 데이터 허용시 -> multiset  
  
키와 데이터를 모두 저장한다 -> map  
중복키를 허용할 경우 -> multimap  
  
속도가 매우 중요해서 최적화를 해야 할 경우 -> unordered set/map

  