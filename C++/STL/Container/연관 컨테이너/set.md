# set

set은 s.insert(10);처럼 insert함수로 값을 넣을 수 있는데 넣는 위치를 지정하지 않고 정렬된 상태를 유지하면서 추가함  
그래서 만약 10 50 20 40 30 순으로 넣어도 begin~end로 출력하면 10 20 30 40 50 순으로 나옴  
set 안에는 중복된 원소가 없음  
10을 여러번 넣어도 10이 이미 있으면 insert를 무시함  
10을 여러개 넣는걸 허용한게 multiset  
  
std::cout << "20 이 s 의 원소인가요? :: ";  
auto itr = s.find(20);  
if (itr != s.end())  
{  
std::cout << "Yes" << std::endl;  
}   
else   
{  
std::cout << "No" << std::endl;  
}  
이런식으로 find해서 itr값이 끝까지 갔는지 중간에 멈췄는지로 판별  
  
set의 내부 구조는 일자로 연속적으로 있는게 아니라 트리구조로 되어있음  
그래서 시퀀스 컨테이너들보다 특정 값을 찾아가는 속도가 빠름  
벡터의 경우 begin부터 end까지 하나씩 비교하며 값을 찾아가야했지만  
set의 경우 트리를 따라가면 되므로 훨씬 빠르게 찾을 수 있음

값이 있냐 없냐를 판별하기에 더 좋은 구조  