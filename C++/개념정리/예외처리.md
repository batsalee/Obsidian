# 예외처리

## 1. exception 클래스

- c++가 제공하는 클래스로써 여러 예외클래스의 기초클래스로 사용할 수 있음
- stdexcept 헤더파일로 사용
- what()이라는 가상멤버함수 제공
- 즉 예외클래스를 직접 만든다면 파생클래스의 what()이라는 함수에 원하는 문자열을 출력하도록 재정의 하면 됨

## 2. 표준 예외 클래스

1) logic\_error
- 일반적인 논리에 대한 오류처리
2) runtime\_error
- 프로그램 실행 중 발생하는 다양한 오류처리

## 3. 예외의 종류

| 예외클래스 | 언제 던져지는가                                                                              | 해당 예외의 헤더파일 |
|:---------- |:-------------------------------------------------------------------------------------------- |:-------------------- |
| bad_alloc | new/new[]연산자로 동적메모리 할당에 실패하는 경우</br>예를들어 컴퓨터에 메모리 자원이 부족한 경우 | new |
| bad_cast | dynamic_cast연산에서 캐스팅이 실패하는 경우</br>예를들어 부모객체를 자식클래스에 캐스팅 시도하는 경우 |  typeinfo                    |
|  bad\_typeid |       typeid연산자가 null포인터를 반환하는 경우   예를들어 typeid(특정nullptr변수).name()처럼 사용하는 경우       |  typeinfo |
|  bad\_exception |       void func() throw (int, char) {} 처럼 작성된 함수에서    int나 char가 아닌 string예외가 발생하는 경우       |  exeption |
|  length\_error |       최대 허용 길이를 초과하는 객체를 만들려 할 때   예를 들어 vector<int> my\_vector;를 만들고   my\_vector.resize(my\_vector.max\_size()+1); 처럼 사용하는 경우       |   |
|  domain\_error |       수학적인 도메인 에러를 탐지할때(결과가 존재하지 않는 인자)   예를들어 루트 안에 음수값이 들어간 경우       |   |
|  out\_of\_range |       배열 범위 검사에서 인자가 index 범위를 초과할때   예를들어 string str = "abc";를 만들고    str.at(10);처럼 사용 시 at멤버가 던짐       |   |
|  invalid\_argument |       함수 인자의 값이 유효하지 않을때   예를 들어 char 자료형은 0~255를 보관할 수 있는데   여기에 256을 넣으려고 할때       |   |
|  overflow\_error |       산술 계산에서 상한값을 초과할 때   예를 들어 아주아주 작은 값으로 나눌 때       | stdexcept |
|  underflow\_error |       산술 계산에서 하한값을 초과할 때   예를들어 아주아주 큰 값으로 나눌 때        |   |
|  range\_error |       계산에서 부동 소수점 값이 너무 크거나 작아서 표현할 수 없을 때    표준 라이브러리의 수학함수들은 이 예외를 발생시키지 않음       |   |
|   bad\_function\_call |       함수 포인터를 이용해 함수를 호출했는데 해당 포인터값이 nullptr인 경우       |   |
|   bad\_weak\_ptr |       만료된 weak\_ptr로 생성된 경우   shared\_ptr의 생성자에 의해 예외 발생         예를들어 shared\_ptr<int> sp(new int(10)); 처럼 만든 후   weak\_ptr<int> wp(sp);처럼 weak\_ptr을 만들고   p.reset();함수를 사용하면 weak\_ptr은 소멸되는데    이 후 wp변수를 사용하는 경우 예외 발생       |   |

\* typeid 연산자

\- 자료형, 클래스, 함수, 객체, enum, 사용자정의 클래스, 멤버함수, 람다함수를 받을수 있는 연산자이며 

\- 해당 자료형이 무엇인지 알려주는 기능

\- cout << typeid(int).name() << endl; 는 int를 출력

\- cout << typeid(cout).name() << endl; 는 class std::basic\_ostream,char, struct std::char\_traits<char>>를 출력

\* 함수에 붙은 throw()

다른 프로그래머가 해당 함수가 어떤 예외를 던지는지 확인하기 쉽게 throw를 이용해 작성해둘 수 있음

void func() throw(char\*, int) {} 라고 작성되어 있으면 해당 함수는 char\*형식과 int형식의 예외를 던진다는것을 알 수 있음

void func() throw() 라고 작성되어 있으면 해당 함수는 예외를 던지지 않는다는 것을 의미, 또는 void func() noexcept라고 작성해도 같은 의미

void func() 라고만 작성되어 있다면 해당 함수는 어떤 예외던 던질수 있다는 의미, 또한 예외를 던지지 않을수도 있음

현장에서는 사용되지 않는다고 하는데 일단 bad\_exception 예외의 설명 이해를 위해 적어둠

\* unexpected함수( terminate함수 )

bad\_exception이 발생하는 경우 지정하지 않은 예외가 발생했으므로 프로그램이 강제로 종료되는데 이를 막기 위해 unexpected 함수를 사용해서 bad\_exeption을 처리해 줄 수 있음

| #include <iostream>   #include <exception>         void my\_unexpected() {   std::cerr << "unexpected handler called\\n";   throw; // bad\_exception이 이 핸들러(함수)로 넘어온 상황인데 이걸 또 throw;해주면 또 상위함수로 던져질테니 아래의 메인함수로 던져짐   }         void func() throw (int) {   throw 'x'; // 예외로 던져진다고 작성된 int가 아닌 char객체가 예외로 던져짐, 즉 bad\_exception 발생   }         void main() {   std::set\_unexpected(my\_unexpected); // bad\_exception이 발생할 경우 my\_unexpected 핸들러가 처리하도록 등록해두는 것   // std::set\_terminate(my\_unexpected); // unexpected함수와 동일한 기능의 함수인듯         try {   func();   }   catch (int) { std::cerr << "int 예외 발생\\n; }   catch (std::bad\_exception be) { std::cerr << "bad\_exepcion 예외 발생\\n; }   } |
| --- |

위 코드를 실행하게 되면 실행결과로

| unexpected handler called   bad\_exepcion 예외 발생 |
| --- |

위처럼 2줄이 나옴

\* shared\_ptr, weak\_ptr

\- 스마트 포인터의 종류

\- 스마트 포인터란 동적할당한 메모리의 메모리 누수를 예방하기 위해 사용하는 것

\- shared\_ptr : 하나의 객체를 참조하는 스마트포인터가 총 몇개인지 확인하는 스마트 포인터

| shared\_ptr<int> ptr1(new int(5)); // int형 shared\_ptr인 ptr1을 선언하고 5로 초기화, 여기서 ptr1.use\_count()는 1   ptr2(ptr1); // ptr2에 ptr1을 복사생성자로 초기화, 여기서 ptr1.use\_count()는 2   ptr3 = ptr1; // 대입을 이용한 초기화, 여기서 ptr1.use\_count()는 3         마지막 shared\_ptr의 수명이 다하면 참조횟수가 0이 되면서 delete해주면 됨 |
| --- |

\- weak\_ptr : shared\_ptr가 소유한 객체에 접근은 가능하지만 소유자의 갯수에는 포함되지 않는 스마트 포인터

                shared\_ptr은 참조횟수를 기반으로 동작하는 스마트포인터인데 만약 서로 상대방을 가리키는 shared\_ptr이 있으면 참조횟수는 절대 0이 되지 않으니 메모리가 해제되지 않음. 이런 상황에서 weak\_ptr을 이용해 shared\_ptr 사이의 순환 참조를 제거한다고 함